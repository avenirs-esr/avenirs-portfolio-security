name: "Setup Postgresql"
description: "Initializes Postgresql environment"
inputs:
  jasypt_password:
    description: "Jasypt encryption password"
    required: true
  postgres_db:
      description: "Postgres database"
      required: true
  postgres_user:
    description: "Postgres user"
    required: true
  postgres_password:
    description: "Postgres user password"
    required: true
  cache_dir:
    description: "Path to the cache directory"
    required: false
    default: "/tmp/.cache-postgres"
  cache_key:
    description: "Cache key"
    required: false
    default: "postgres-cache-v1"
  cache_restore_key:
    description: "Cache key"
    required: false
    default: "postgres-cache-"
runs:
  using: "composite"
 
  steps:

    - name: Ensure Cache Directory Exists
      run: |
        cache_dir=${{inputs.cache_dir}}
        [ -e $cache_dir ] && echo "Cache directory found: $cache_dir"  \
           || { mkdir -p $cache_dir; echo "Cache directory created: $cache_dir"; }
        echo "Cache directory ensured: $cache_dir"
      shell: bash

    - name: Cache Docker Images for Postgresql
      uses: actions/cache@v4
      with:
        path: ${{inputs.cache_dir}}
        key: postgres-cache-${{ runner.os }}-${{ hashFiles('${{inputs.cache_dir}}/digest', '${{inputs.cache_dir}}/postgres.tar') }}
        restore-keys: |
          postgres-cache-${{ runner.os }}-
          postgres-cache-


    - name: (DEBUG) Check Cache Restoration
      if: ${{true}}
      run: |
           echo "Checking restored cache:"
           ls ${{inputs.cache_dir}}/
      shell: bash

    - name: Load Postgresql Image from Cache
      run: |
        if [ -f ${{inputs.cache_dir}}/postgres.tar ]; then
          echo "Loading Postgresql image from cache..."
          docker load -i ${{inputs.cache_dir}}/postgres.tar
           echo "Postgresql image loaded from cache."
        else
          echo "No cached Postgresql image found."
        fi
      shell: bash

    - name: Check for Updates or Missing Postgresql Image
      run: |
        LOCAL_DIGEST=$(cat ${{inputs.cache_dir}}/digest 2>/dev/null || echo "none")
        REMOTE_DIGEST=$(docker manifest inspect postgres:latest | jq -r '.manifests[0].digest' 2>/dev/null || echo "none")
        echo "Local Digest: $LOCAL_DIGEST"
        echo "Remote Digest: $REMOTE_DIGEST"
        if [ "$LOCAL_DIGEST" != "$REMOTE_DIGEST" ] || [ "$LOCAL_DIGEST" == "none" ]; then
          echo "Pulling updated Postgresql Docker image..."
          docker pull postgres:latest
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' postgres:latest | awk -F '@' '{print $2}')
          echo "Valeur du digest: $DIGEST"
        
          echo "LS avant"
          ls ${{inputs.cache_dir}}/
          echo "$DIGEST" > ${{inputs.cache_dir}}/digest
          echo "LS apr√®s"
          ls ${{inputs.cache_dir}}/
        
          docker save postgres:latest -o ${{inputs.cache_dir}}/postgres.tar
          echo "Postgresql image pulled and saved to cache."
        else
          echo "Postgresql image is up-to-date and loaded from cache."
        fi
      shell: bash

    - name: Save Updated Cache
      uses: actions/cache@v4
      with:
        path: ${{inputs.cache_dir}}
        key: postgres-cache-${{ runner.os }}-${{ hashFiles('${{inputs.cache_dir}}/digest', '${{inputs.cache_dir}}/postgres.tar') }}
        restore-keys: |
          postgres-cache-${{ runner.os }}-
          postgres-cache-

    - name: Verify Digest in Cache After Save
      run: |
        echo "Verifying cache contents:"
        ls -la ${{inputs.cache_dir}}/
        if [ ! -f ${{inputs.cache_dir}}/digest ]; then
          echo "Error: Digest file was not saved to the cache!"
          exit 1
        fi
      shell: bash

    - name: Verify Cache After Save
      run: |
          echo "Verifying cache after save:"
          ls -la ${{inputs.cache_dir}}/
          cat ${{inputs.cache_dir}}/digest || echo "No digest found in cache"
      shell: bash

    - name: Start Postgresql Container
      run: |
        echo "Starting Postgresql Docker container..."
        docker run -d --name avenirs-postgres \
          --network avenirs-network \
          -e POSTGRES_USER=${{inputs.postgres_user}} \
          -e POSTGRES_PASSWORD=${{inputs.postgres_password}} \
          -e POSTGRES_DB=${{inputs.postgres_db}} \
          -p 65432:5432 \
          postgres:latest
      shell: bash

    - name: Wait for Postgresql to be ready
      run: |
        echo "Waiting for Postgresql to be ready..."
        for i in {1..4}; do
          if docker exec avenirs-postgres pg_isready -U ${{inputs.postgres_user}} -h localhost -p 5432; then
            echo "Postgresql is ready."
            break
          fi
          echo "Postgresql is not ready yet... retrying in 5 seconds."
          sleep 5
        done
      shell: bash

    - name: Initialize Database
      run: |
        for FILE in src/main/resources/db/init-db.sql src/test/resources/db/init-test-db.sql; do \
          if [ -f "$FILE" ]; then \
            encrypted=$(grep -o 'ENC([A-Za-z0-9+/=]*)' "$FILE" | sed -E 's/ENC\((.*)\)/\1/'); \
            if [ -n "$encrypted" ]; then \
              decrypted=$(java -cp .github/lib/jasypt-1.9.3.jar org.jasypt.intf.cli.JasyptPBEStringDecryptionCLI input="$encrypted" password=${{inputs.jasypt_password}} algorithm=PBEWithMD5AndDES | grep -v '^$' | tail -n 1); \

              if [ -n "$decrypted" ]; then \
                echo "Decryption successful for $FILE"; \
                sed "s|ENC($encrypted)|$decrypted|" "$FILE" | docker exec -i avenirs-postgres psql -U ${{inputs.postgres_user}} -d template1; \
              else \
                echo "Decryption failed for $FILE: No decrypted value returned. Please check the encrypted string or password."; \
                exit 1; \
              fi; \
            else \
              echo "No encrypted value found in $FILE"; \
            fi; \
          else \
            echo "File $FILE not found"; \
            exit 1; \
          fi; \
        done
      shell: bash

