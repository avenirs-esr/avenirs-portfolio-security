<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JWTService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">avenirs-portfolio-security</a> &gt; <a href="index.source.html" class="el_package">fr.avenirsesr.portfolio.security.services</a> &gt; <span class="el_source">JWTService.java</span></div><h1>JWTService.java</h1><pre class="source lang-java linenums">package fr.avenirsesr.portfolio.security.services;

import java.math.BigInteger;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.RSAPublicKeySpec;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.configurationprocessor.json.JSONArray;
import org.springframework.boot.configurationprocessor.json.JSONException;
import org.springframework.boot.configurationprocessor.json.JSONObject;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.client.RestClient;
import org.springframework.web.client.RestClientResponseException;

import fr.avenirsesr.portfolio.security.configuration.JWTToCryptographicKeyAlgoMapper;
import fr.avenirsesr.portfolio.security.models.ModulusAndExponent;
import fr.avenirsesr.portfolio.security.models.OIDCAccessTokenResponse;
import fr.avenirsesr.portfolio.security.models.OIDCIdToken;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.SignatureException;

/**
 * Service used to checks and parse JWT. 
 * @implNote Only RSA algorithms are supported to generate the public keys.
 */
@Service()
<span class="fc" id="L39">public class JWTService {</span>

	/** Logger */
<span class="fc" id="L42">	private static final Logger LOGGER = LoggerFactory.getLogger(AuthenticationService.class);</span>

	/** Mapping between jwt and cryptographic key algorithm (e.g. RS256 -&gt; RSA). */
	@Autowired
	private JWTToCryptographicKeyAlgoMapper algoMapper;

	/** OIDC provider JWKS end point. */
	@Value(&quot;${avenirs.authentication.oidc.provider.jwks.url}&quot;)
	private String oidcJWKSURL;
	
	/** Public keys indexed by their corresponding kid in the JWKS. */
<span class="fc" id="L53">	private Map&lt;String, PublicKey&gt; keysRepository = new HashMap&lt;String, PublicKey&gt;();</span>

	/** Rest client to retrieve JWKS data. */
<span class="fc" id="L56">	private RestClient client = RestClient.create();</span>
	
	

	/**
	 * Retrieves the modulus and exponent for a RSA key.
	 * @param kid The key id.
	 * @return The modulus and exponent fetched from the OIDC provider end point.
	 */
	private Optional&lt;ModulusAndExponent&gt; fetchModulusAndExponent(String kid) {
		try {
			// Fetches the JWKS from the OIDC provider end point.
<span class="fc" id="L68">			String jwksResponse = client.get().uri(oidcJWKSURL).retrieve().body(String.class);</span>

			// Extracts the modulus and exponent corresponding to the key id (kid).
<span class="fc" id="L71">			return extractModulusAndExponent(jwksResponse, kid);</span>

<span class="nc" id="L73">		} catch (RestClientResponseException e) {</span>
<span class="nc" id="L74">			LOGGER.error(</span>
					&quot;fetchModulusAndExponent, unable to fetch Modulus and Exponent. HTTP Status code: {}, response body&quot;,
<span class="nc" id="L76">					e.getStatusCode().value(), e.getResponseBodyAsString());</span>
<span class="nc" id="L77">			LOGGER.error(&quot;Excetion: &quot;, e);</span>

<span class="nc" id="L79">		} catch (Exception e) {</span>
<span class="nc" id="L80">			LOGGER.error(&quot;Excetion: &quot;, e);</span>
<span class="nc" id="L81">		}</span>
<span class="nc" id="L82">		return Optional.empty();</span>
	}

	/**
	 * Extracts the modulus and exponent corresponding to a key id from a JWKS response.
	 * @param jwksResponse The JWKS .
	 * @param kid The key id of the key associated to the modulus &amp;amp; exponent.
	 * @return An Optional of ModulusAndExponent.
	 */
	protected Optional&lt;ModulusAndExponent&gt; extractModulusAndExponent(String jwksResponse, String kid) {
		try {
<span class="fc" id="L93">			JSONObject jsonObject = new JSONObject(jwksResponse);</span>
<span class="fc" id="L94">			JSONArray keys = jsonObject.getJSONArray(&quot;keys&quot;);</span>

<span class="pc bpc" id="L96" title="1 of 2 branches missed.">			for (int i = 0; i &lt; keys.length(); i++) {</span>
<span class="fc" id="L97">				JSONObject key = keys.getJSONObject(i);</span>

<span class="fc" id="L99">				String kidToTest = key.getString(&quot;kid&quot;);</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">				if (kidToTest.equals(kid)) {</span>
<span class="fc" id="L101">					String modulusBase64Url = key.getString(&quot;n&quot;);</span>
<span class="fc" id="L102">					String exponentBase64Url = key.getString(&quot;e&quot;);</span>

<span class="fc" id="L104">					String modulusBase64 = modulusBase64Url.replace(&quot;-&quot;, &quot;+&quot;).replace(&quot;_&quot;, &quot;/&quot;);</span>
<span class="fc" id="L105">					String exponentBase64 = exponentBase64Url.replace(&quot;-&quot;, &quot;+&quot;).replace(&quot;_&quot;, &quot;/&quot;);</span>

<span class="fc" id="L107">					byte[] modulusBytes = Base64.getDecoder().decode(modulusBase64);</span>
<span class="fc" id="L108">					byte[] exponentBytes = Base64.getDecoder().decode(exponentBase64);</span>

<span class="fc" id="L110">					BigInteger modulus = new BigInteger(1, modulusBytes);</span>
<span class="fc" id="L111">					BigInteger exponent = new BigInteger(1, exponentBytes);</span>

<span class="fc" id="L113">					return Optional.of(new ModulusAndExponent(modulus, exponent));</span>
				}
			}
<span class="nc" id="L116">		} catch (Exception e) {</span>
<span class="nc" id="L117">			LOGGER.error(&quot;extractModulusAndExponent, error&quot;, e);</span>
<span class="nc" id="L118">		}</span>
<span class="nc" id="L119">		return Optional.empty();</span>
	}


	/**
	 * Generates a RSA public key.
	 * @param alg The algorithm specified in the id token.
	 * @param modulusAndExponent The modulus and exponent.
	 * @return An Optional of the Public key.
	 */
	protected Optional&lt;PublicKey&gt; generateRSAPublicKey(String alg, ModulusAndExponent modulusAndExponent) {

		try {
			// Builds the key specification.
<span class="fc" id="L133">			RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(modulusAndExponent.getModulus(),</span>
<span class="fc" id="L134">				modulusAndExponent.getExponent());</span>

		
<span class="fc" id="L137">			final Optional&lt;String&gt; keyAlgo = algoMapper.mapJWTToCryptographicKey(alg);</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">			if (keyAlgo.isEmpty()) {</span>
<span class="nc" id="L139">				LOGGER.error(&quot;generatePublicKey, unable to map jwt alg {}, from mapping defined in properties&quot;, alg);</span>
<span class="nc" id="L140">				return Optional.empty();</span>
			}
			
<span class="fc" id="L143">			KeyFactory keyFactory = KeyFactory.getInstance(keyAlgo.get());</span>
<span class="fc" id="L144">			return Optional.of(keyFactory.generatePublic(rsaPublicKeySpec));</span>
<span class="nc" id="L145">		} catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L146">			LOGGER.error(&quot;generateRSAPublicKey, invalid algorim alg: {}&quot;, alg);</span>
<span class="nc" id="L147">			LOGGER.error(&quot;generateRSAPublicKey&quot;, e);</span>
<span class="nc" id="L148">		} catch (InvalidKeySpecException e) {</span>
<span class="nc" id="L149">			LOGGER.error(&quot;generateRSAPublicKey&quot;, e);</span>
<span class="nc" id="L150">		}</span>
<span class="nc" id="L151">		return Optional.empty();</span>
	}

	/**
	 * Gives the public key associated to an idToken header. If the key does not
	 * exist in the key repository it is generated.
	 * 
	 * @param idToken The id token which contains in its header the properties kid and alg.
	 * @return An optional of the publicKey.
	 */
	protected Optional&lt;PublicKey&gt; getPublicKey(OIDCIdToken idToken) {
<span class="pc bpc" id="L162" title="2 of 4 branches missed.">		if (idToken != null &amp;&amp; StringUtils.hasLength(idToken.getHeader())) {</span>

			try {
<span class="fc" id="L165">				JSONObject jsonObject = new JSONObject(idToken.getHeader());</span>
<span class="fc" id="L166">				String kid = jsonObject.getString(&quot;kid&quot;);</span>

<span class="pc bpc" id="L168" title="1 of 2 branches missed.">				if (!StringUtils.hasLength(kid)) {</span>
<span class="nc" id="L169">					LOGGER.error(&quot;getPublicKey, Unable to fetch kid from idToken: {}&quot;, idToken);</span>
<span class="nc" id="L170">					return Optional.empty();</span>
				}

				// The key is not in the repository so it is generated.
<span class="fc bfc" id="L174" title="All 2 branches covered.">				if (!this.keysRepository.containsKey(kid)) {</span>
<span class="fc" id="L175">					String alg = jsonObject.getString(&quot;alg&quot;);</span>

<span class="pc bpc" id="L177" title="1 of 2 branches missed.">					if (!StringUtils.hasLength(alg)) {</span>
<span class="nc" id="L178">						LOGGER.error(&quot;getPublicKey, Unable to fetch alg from idToken: {}&quot;, idToken);</span>
<span class="nc" id="L179">						return Optional.empty();</span>
					}
					
					
<span class="fc" id="L183">					Optional&lt;ModulusAndExponent&gt; modulusAndExponent = this.fetchModulusAndExponent(kid);</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">					if (modulusAndExponent.isEmpty()) {</span>
<span class="nc" id="L185">						return Optional.empty();</span>
					}

<span class="fc" id="L188">					Optional&lt;PublicKey&gt; publicKey = this.generateRSAPublicKey(alg, modulusAndExponent.get());</span>

<span class="pc bpc" id="L190" title="1 of 2 branches missed.">					if (publicKey.isEmpty()) {</span>
<span class="nc" id="L191">						LOGGER.error(&quot;getPublicKey, Error while trying to generate public key from kid{}, idToken: {}&quot;,</span>
								kid, idToken);
<span class="nc" id="L193">						return Optional.empty();</span>
					}

<span class="fc" id="L196">					this.keysRepository.put(kid, publicKey.get());</span>
				}
<span class="fc" id="L198">				return Optional.of(this.keysRepository.get(kid));</span>

<span class="nc" id="L200">			} catch (JSONException e) {</span>
<span class="nc" id="L201">				LOGGER.error(&quot;getPublicKey invalid JSON&quot;, e);</span>
<span class="nc" id="L202">			} catch (Exception e) {</span>
<span class="nc" id="L203">				LOGGER.error(&quot;getPublicKey&quot;, e);</span>
<span class="nc" id="L204">			}</span>
		}
<span class="nc" id="L206">		return Optional.empty();</span>

	}

	/**
	 * Parses an access token and checks its signature.
	 * @param accessTokenResponse The access token response which contains the
	 *                            access token and the id token.
	 * @return An Optional of Claims.
	 */
	public Optional&lt;Claims&gt; parseAndCheckSignature(OIDCAccessTokenResponse accessTokenResponse) {
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">		if (accessTokenResponse == null) {</span>
<span class="nc" id="L218">			return Optional.empty();</span>
		}
<span class="fc" id="L220">		final Optional&lt;PublicKey&gt; publicKey = getPublicKey(accessTokenResponse.getIdToken());</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">		if (publicKey.isEmpty()) {</span>
<span class="nc" id="L222">			LOGGER.error(&quot;Empty public key while trying to fetch claims from accessTokenResponse: {}&quot;,</span>
					accessTokenResponse);
<span class="nc" id="L224">			return Optional.empty();</span>
		}

		try {
			// Parses and checks signature.
<span class="fc" id="L229">			final Claims claims = Jwts.parser()</span>
<span class="fc" id="L230">					.verifyWith(publicKey.get())</span>
<span class="fc" id="L231">					.build()</span>
<span class="fc" id="L232">					.parseSignedClaims(accessTokenResponse.getAccessToken()).getPayload();</span>

<span class="fc" id="L234">			return Optional.of(claims);</span>
<span class="nc" id="L235">		} catch (SignatureException e) {</span>
<span class="nc" id="L236">			LOGGER.error(&quot;Invalid signature of access token in access token response: {}&quot;, accessTokenResponse);</span>
<span class="nc" id="L237">			return Optional.empty();</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>